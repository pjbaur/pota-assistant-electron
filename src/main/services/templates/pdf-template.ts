/**
 * PDF Export Template
 *
 * Generates PDF output for activation plans using pdfmake.
 */

import type { TDocumentDefinitions, Content } from 'pdfmake/interfaces';
import type { Plan } from '../../../shared/types/plan';

/**
 * Generate a PDF document definition for a plan
 */
export function generatePdfDefinition(plan: Plan): TDocumentDefinitions {
  const content: Content[] = [];

  // Title
  content.push({
    text: plan.name,
    style: 'header',
    alignment: 'center',
  });

  content.push({ text: '', margin: [0, 10] }); // Spacer

  // Plan Details section
  content.push({
    text: 'Plan Details',
    style: 'subheader',
  });

  const detailsTable: Content = {
    table: {
      widths: ['auto', '*'],
      body: [
        ['Park Reference:', plan.parkReference],
        ['Activation Date:', plan.activationDate],
        ['Time:', `${plan.startTime} - ${plan.endTime}`],
        ['Status:', formatStatus(plan.status)],
        ...(plan.operatorCallsign ? [['Operator:', plan.operatorCallsign]] : []),
      ],
    },
    layout: 'noBorders',
    margin: [0, 5, 0, 15],
  };
  content.push(detailsTable);

  // Equipment section
  if (plan.equipmentPreset) {
    content.push({
      text: 'Equipment',
      style: 'subheader',
    });

    const equipmentTable: Content = {
      table: {
        widths: ['auto', '*'],
        body: [
          ['Preset Name:', plan.equipmentPreset.name],
          ['Radio:', plan.equipmentPreset.radio],
          ['Antenna:', plan.equipmentPreset.antenna],
          ['Power:', `${plan.equipmentPreset.powerWatts}W`],
          ['Mode:', plan.equipmentPreset.mode],
          ...(plan.equipmentPreset.notes ? [['Notes:', plan.equipmentPreset.notes]] : []),
        ],
      },
      layout: 'noBorders',
      margin: [0, 5, 0, 15],
    };
    content.push(equipmentTable);
  }

  // Bands section
  if (plan.bands.length > 0) {
    content.push({
      text: 'Planned Bands',
      style: 'subheader',
    });

    content.push({
      text: plan.bands.join(', '),
      margin: [0, 5, 0, 15],
    });
  }

  // Time Slots section
  if (plan.timeSlots.length > 0) {
    content.push({
      text: 'Time Slots',
      style: 'subheader',
    });

    const timeSlotBody: string[][] = [
      ['Time', 'Band', 'Mode', 'Frequency', 'Notes'],
      ...plan.timeSlots.map(slot => [
        `${slot.startTime} - ${slot.endTime}`,
        slot.band,
        slot.mode,
        slot.frequency ? `${slot.frequency} MHz` : '-',
        slot.notes || '-',
      ]),
    ];

    const timeSlotsTable: Content = {
      table: {
        headerRows: 1,
        widths: ['auto', 'auto', 'auto', 'auto', '*'],
        body: timeSlotBody,
      },
      layout: 'lightHorizontalLines',
      margin: [0, 5, 0, 15],
    };
    content.push(timeSlotsTable);
  }

  // Notes section
  if (plan.notes) {
    content.push({
      text: 'Notes',
      style: 'subheader',
    });

    content.push({
      text: plan.notes,
      margin: [0, 5, 0, 15],
    });
  }

  // Footer
  content.push({ text: '', margin: [0, 20] }); // Spacer
  content.push({
    text: 'Generated by POTA Activation Planner',
    style: 'footer',
    alignment: 'center',
  });
  content.push({
    text: `Created: ${formatDate(plan.createdAt)}`,
    style: 'footer',
    alignment: 'center',
  });
  content.push({
    text: `Last Modified: ${formatDate(plan.updatedAt)}`,
    style: 'footer',
    alignment: 'center',
  });

  return {
    content,
    styles: {
      header: {
        fontSize: 18,
        bold: true,
        margin: [0, 0, 0, 10] as [number, number, number, number],
      },
      subheader: {
        fontSize: 14,
        bold: true,
        margin: [0, 10, 0, 5] as [number, number, number, number],
      },
      footer: {
        fontSize: 9,
        color: '#666666',
      },
    },
    defaultStyle: {
      fontSize: 11,
    },
  };
}

/**
 * Format plan status for display
 */
function formatStatus(status: string): string {
  const statusMap: Record<string, string> = {
    draft: 'Draft',
    finalized: 'Finalized',
    completed: 'Completed',
    cancelled: 'Cancelled',
  };
  return statusMap[status] ?? status;
}

/**
 * Format ISO date string to readable format
 */
function formatDate(isoDate: string): string {
  try {
    const date = new Date(isoDate);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch {
    return isoDate;
  }
}
