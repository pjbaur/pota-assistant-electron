/**
 * Plain Text Export Template
 *
 * Generates clean, readable plain text output for activation plans.
 */

import type { Plan } from '../../../shared/types/plan';

/**
 * Generate a plain text representation of a plan
 */
export function generateText(plan: Plan): string {
  const lines: string[] = [];

  // Header
  lines.push('='.repeat(60));
  lines.push('');
  lines.push(centerText(plan.name, 60));
  lines.push('');
  lines.push('='.repeat(60));
  lines.push('');

  // Plan Details
  lines.push('PLAN DETAILS');
  lines.push('-'.repeat(60));
  lines.push(`Park Reference:  ${plan.parkReference}`);
  lines.push(`Activation Date: ${plan.activationDate}`);
  lines.push(`Time:            ${plan.startTime} - ${plan.endTime}`);
  lines.push(`Status:          ${formatStatus(plan.status)}`);

  if (plan.operatorCallsign) {
    lines.push(`Operator:        ${plan.operatorCallsign}`);
  }

  lines.push('');

  // Equipment section
  if (plan.equipmentPreset) {
    lines.push('EQUIPMENT');
    lines.push('-'.repeat(60));
    lines.push(`Preset:   ${plan.equipmentPreset.name}`);
    lines.push(`Radio:    ${plan.equipmentPreset.radio}`);
    lines.push(`Antenna:  ${plan.equipmentPreset.antenna}`);
    lines.push(`Power:    ${plan.equipmentPreset.powerWatts}W`);
    lines.push(`Mode:     ${plan.equipmentPreset.mode}`);

    if (plan.equipmentPreset.notes) {
      lines.push(`Notes:    ${plan.equipmentPreset.notes}`);
    }

    lines.push('');
  }

  // Bands section
  if (plan.bands.length > 0) {
    lines.push('PLANNED BANDS');
    lines.push('-'.repeat(60));
    lines.push(plan.bands.join(', '));
    lines.push('');
  }

  // Time Slots section
  if (plan.timeSlots.length > 0) {
    lines.push('TIME SLOTS');
    lines.push('-'.repeat(60));

    for (const slot of plan.timeSlots) {
      lines.push('');
      lines.push(`  ${slot.startTime} - ${slot.endTime}`);
      lines.push(`    Band:      ${slot.band}`);
      lines.push(`    Mode:      ${slot.mode}`);

      if (slot.frequency) {
        lines.push(`    Frequency: ${slot.frequency} MHz`);
      }

      if (slot.notes) {
        lines.push(`    Notes:     ${slot.notes}`);
      }
    }

    lines.push('');
  }

  // Notes section
  if (plan.notes) {
    lines.push('NOTES');
    lines.push('-'.repeat(60));
    lines.push(wrapText(plan.notes, 60));
    lines.push('');
  }

  // Footer
  lines.push('='.repeat(60));
  lines.push('Generated by POTA Activation Planner');
  lines.push(`Created: ${formatDate(plan.createdAt)}`);
  lines.push(`Last Modified: ${formatDate(plan.updatedAt)}`);
  lines.push('='.repeat(60));

  return lines.join('\n');
}

/**
 * Center text within a given width
 */
function centerText(text: string, width: number): string {
  if (text.length >= width) {
    return text;
  }
  const padding = Math.floor((width - text.length) / 2);
  return ' '.repeat(padding) + text;
}

/**
 * Format plan status for display
 */
function formatStatus(status: string): string {
  const statusMap: Record<string, string> = {
    draft: 'Draft',
    finalized: 'Finalized',
    completed: 'Completed',
    cancelled: 'Cancelled',
  };
  return statusMap[status] ?? status;
}

/**
 * Format ISO date string to readable format
 */
function formatDate(isoDate: string): string {
  try {
    const date = new Date(isoDate);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch {
    return isoDate;
  }
}

/**
 * Wrap text to a maximum width, preserving existing line breaks
 */
function wrapText(text: string, width: number): string {
  const paragraphs = text.split('\n');
  return paragraphs
    .map(paragraph => {
      if (paragraph.length <= width) {
        return paragraph;
      }

      const words = paragraph.split(' ');
      const lines: string[] = [];
      let currentLine = '';

      for (const word of words) {
        if (currentLine.length + word.length + 1 <= width) {
          currentLine = currentLine ? `${currentLine} ${word}` : word;
        } else {
          if (currentLine) {
            lines.push(currentLine);
          }
          currentLine = word;
        }
      }

      if (currentLine) {
        lines.push(currentLine);
      }

      return lines.join('\n');
    })
    .join('\n');
}
